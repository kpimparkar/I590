---
title: "SP19_Applied_DS_Final_Project"
author: "Ketan Pimparkar"
date: "April 26, 2019"
output: 
  html_document: 
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## IMPORTING REQUIRED R LIBRARIES
- ggplot2 : For data visualization
- dplyr   : For data wrangling
- corrplot: For correlation plots
- zoo     : For data manipulation
- cluster : clustering algorithms
- factoextra : clustering algorithms & visualization
- tidyverse  : Data manipulation


```{r warning=FALSE}
library(ggplot2)
library(dplyr)
library(corrplot)
library(zoo)
library(cluster)
library(factoextra)
library(tidyverse)
```

## IMPORTING THE DATASET FROM .csv FILE
- Importing the .csv file useg read.csv 
- creating a data frame with the data from the read .csv

```{r warning=FALSE}
## setwd() generates a warning indicating setwd is effective only for this code chunk. Added warnings=FALSE to suppress this warning

currDir <- getwd()
setwd("C:/Study/IUMSDS/Spring2019/Applied DS/data")

df <- read.csv('gapminder.csv')

```
## DESCRIBING THE DATASET

```{r}
# line1 holds the dimension of the data frame.
line1 <- paste("The data set contains ",nrow(df), "observations, each observation with", ncol(df), "attributes(variables)")

#Function to return count of unique values 
getCountD <- function(x){
   length(unique(x))
}


#Loop to access all attributes of the data set and store data type, number of unique values in a string 'lineD'

lineD <- " "
for (col in names(df)){
  dtype <- sapply(df,class)[match(col, names(df))]
  lineD <- paste(lineD ,'\n',"- Attribute",col,"is of data type",dtype,"and has",sapply(df,getCountD)[match(col, names(df))],"unique values.")

#Added below code to show how dispersed an integer attribute is in this dataset
  if (dtype == "integer"){
      lineD <- paste(lineD, "\n","\t","- The range of",col,"is from", min(df[[col]], na.rm=TRUE),"to",max(df[[col]], na.rm=TRUE))
  }
}


```

- `r line1`

`r lineD`

## CHECKING NULL VALUES
- There are 2341 null values in 'income' column of the dataset

```{r}
#Following for loop indicates that there are 2341 null values in 'income' column of the dataset

for (col in (names(df))){
  print(paste(col, "nulls:",sum(is.na(df[[col]]))))
}

```

## DATA WRANGLING

- Convert population to integer
  - population column has numbers in 999,999,999 format. This step converts all population values to integers
- Fetching values for intermediate years
  - The data set has population only last year of the decade. 


```{r}
#Converting population column from factor to an integer column
#Removing commas from population column

df$poulation1 <- as.integer(gsub(",","",as.character(df$population)))

#Filling NAs in population1 column with last non NA value using na.locf function of zoo library 

df$pop1 <- na.locf(df$poulation1)

df$income <- na.locf(df$income)
```

```{r echo=FALSE}
############ NOTE ########
# Befor eusing na.locf(), I wrote following function. This function works correctly on smaller dataframes but it generated wrong population for the whole dataset. Could not find out the reason, finally used na.locf() instead.

#df$pop1 <- as.integer(gsub(",","",as.character(df$population)))
#getPop <- function(country,year){
#  if (year%%10 == 0){
#    as.integer(filter(df, df$Country==country & df$Year==(year - year%%10))$pop1)
#    #print(paste(country, year, as.integer(filter(df, df$Country==country & df$Year==(year - year%%10))$pop1)))
#  }
#  else {
#    as.integer(filter(df, df$Country==country & df$Year==(year - year%%10))$pop1)
#    #print(paste(country, year, as.integer(filter(df, df$Country==country & df$Year==(year - year%%10))$pop1)))
#  }
#}
#df_new <- mutate(df, pop_new =mapply(getPop, country=df$Country, year=df$Year))

######### OUTPUT ##########

#Country Year life population income region pop1 pop_new
#<fctr>  <int>  <dbl>  <fctr>  <int>  <fctr>  <int>  <list>
#Afghanistan	1800	28.211000	3280000	603	South Asia	3280000	<int [1]>
#Afghanistan	1801	28.200753		603	South Asia	NA	<int [1]>
```

```{r echo=FALSE}
# line1 holds the dimension of the data frame.
line1 <- paste("The data set contains ",nrow(df), "observations, each observation with", ncol(df), "attributes(variables)")

#Function to return count of unique values 
getCountD <- function(x){
   length(unique(x))
}

#Loop to access all attributes of the data set and store data type, number of unique values in a string 'lineD'

lineD <- " "
for (col in names(df)){
  dtype <- sapply(df, class)[match(col, names(df))]
  lineD <- paste(lineD ,'\n',"- Attribute",col,"is of data type",dtype,"and has",sapply(df, getCountD)[match(col, names(df))],"unique values.")

#Added below code to show how dispersed an integer attribute is in this dataset
  if (dtype == "integer"){
      lineD <- paste(lineD, "\n","\t","- The range of",col,"is from", min(df[[col]], na.rm=TRUE),"to",max(df[[col]], na.rm=TRUE))
  }
}

```
For the new data : 
`r line1`
`r lineD`


## EXPLORATORY DATA ANALYSIS

```{r}
## CHECKING MEDIAN LIFE EXPECTANCY FOR EACH REGION
print("MEDIAN LIFE EXPECTANCY FOR EACH REGION : ")
aggregate(life ~ region, df, median)

## CHECKING MEAN LIFE EXPECTANCY FOR EACH REGION
print("MEAN LIFE EXPECTANCY FOR EACH REGION : ")
aggregate(life ~ region, df, mean)

max(df$Year)

df_2015 <- filter(df, df$Year==2015)

incomeRegion <- df_2015 %>% 
  group_by(region) %>% 
  summarize(avgIncome = mean(income))


# plotting avg income for each region for year 2015

ggplot(incomeRegion, 
  aes(x = region, y = avgIncome, color = region)) +
  geom_point(size=4) +
  ggtitle("2015 Average Income by Region") +
  xlab("Region") + ylab("Avg. Income") +
  theme(axis.text.x=element_text(angle=10))

```


```{r}
RegionTrend <- df %>% 
  group_by(Year, region) %>% 
  summarize(avgIncome = mean(income, na.rm=TRUE), avgLife = mean(life,na.rm = TRUE))

ggplot(RegionTrend, 
  aes(x = Year, y = avgIncome, color = region)) +
  geom_smooth(se=FALSE) +
  ggtitle("Time trend of Average Income by Region") +
  xlab("Year") + ylab("Avg. Income") 

ggplot(RegionTrend, 
  aes(x = Year, y = avgLife, color = region)) +
  geom_smooth(se=FALSE) +
  ggtitle("Time trend of Average Life expectancy by Region") +
  xlab("Year") + ylab("Avg. Life expectancy")  

```

```{r}
ggplot(df_2015, aes(x = region, y = life)) +
  geom_boxplot(outlier.colour = "hotpink") +
  geom_jitter(position = position_jitter(width = 0.1, height = 0), alpha = 1/4) +
  ggtitle("Box plot of life expectancy by Region for year 2015") +
  ylab("Life expectancy") + xlab("Region")  +
  coord_flip() 
  
```


- TO SHOW THAT, OVER THE PERIOD DEPENDENCY OF LIFE EXPECTANCY ON INCOME HAS REDUCED

```{r}
#library(gridExtra)

## TO SHOW THAT, OVER THE PERIOD DEPENDENCY OF LIFE EXPECTANCY ON INCOME HAS REDUCED
df_1900 <- filter(df, df$Year==1900)

#par( mfrow = c(2,2) )

#p1 <- 
ggplot(data=df_1900) +
  geom_point(mapping = aes(x=income, y=life, color=region, alpha=0.4)) +
  ggtitle("High dependency of life expectancy on income for year 1900") +
  ylab("Life expectancy") + xlab("Income")  
  #theme(legend.position="bottom")

#p2 <- 
ggplot(data=df_2015) +
  geom_point(mapping = aes(x=income, y=life, color=region, alpha=0.4)) +
  ggtitle("Low dependency of life expectancy on income for year 2015") +
  ylab("Life expectancy") + xlab("Income")  
  #theme(legend.position="bottom")

#grid.arrange(p1,p2,ncol=2)

```

```{r}

corrplot(cor(df[c('Year','life','income','pop1')]),addCoef.col="grey", title="Correlation plot of all numeric attributes of the dataset for all counties")

df_india <- filter(df, df$Country=='India')
corrplot(cor(df_india[c('Year','life','income','pop1')]),addCoef.col="grey", title="Correlation plot of all numeric attributes of the dataset for India")


```


## DATA CONVERSIONS FOR CLUSTER AND REGRESSION ANALYSIS
- converting "region" attribute to a numerical sequence so that it can be used in data analysis
- Eliminating unwanted attributes such as population , region (text) and population1

```{r}
regionConv <- function(x){
  if (x == "South Asia"){
    1
  } else if (x == "Europe & Central Asia") {
    2
  } else if (x == "Middle East & North Africa") {
    3
  } else if (x == "Sub-Saharan Africa") {
    4
  } else if (x == "America") {
    5
  } else if (x == "East Asia & Pacific") {
    6
  }
}

df$region_num <- sapply(df$region, regionConv)

country_list <- unique(df$Country)
df$country_id <- match(df$Country, country_list)

df_clean <- df[c("country_id","Year","life","income","region_num","pop1")]

df2 <- df[c("Year","life","income","pop1")]
```
                                 
### Elbow Method
```{r}
# function to compute total within-cluster sum of square 
wss <- function(k) {
  kmeans(df_clean, k, nstart = 10 )$tot.withinss
}

# Compute and plot wss for k = 1 to k = 15
k.values <- 1:15

# extract wss for 2-15 clusters
wss_values <- map_dbl(k.values, wss)

plot(k.values, wss_values,
       type="b", pch = 19, frame = FALSE, 
       xlab="Number of clusters K",
       ylab="Total within-clusters sum of squares")
```

### Cluster Visualization
```{r}
fit1 <- kmeans(df_clean, 4, nstart = 25)
fviz_cluster(fit1, data = df_clean)
```

```{r}
fit2 <- kmeans(df2, 4, nstart = 25)
fviz_cluster(fit2, data = df2)
```

```{r}

df_india <- filter(df_clean, df_clean$country_id==match('India',country_list))

df_india <- df_india[c("Year"   ,    "life"    ,   "income"    , "pop1")]

fit3 <- kmeans(df_india, 4, nstart = 25)
fviz_cluster(fit3, data = df_india)
```