---
title: "SP19_Applied_DS_Final_Project"
author: "Ketan Pimparkar"
date: "April 26, 2019"
output: 
  html_document: 
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## IMPORTING REQUIRED R LIBRARIES
- ggplot2 : For data visualization
- dplyr   : For data wrangling
- corrplot: For correlation plots


```{r warning=FALSE}
library(ggplot2)
library(dplyr)
library(corrplot)
```

## IMPORTING THE DATASET FROM .csv FILE
- Importing the .csv file useg read.csv 
- creating a data frame with the data from the read .csv

```{r warning=FALSE}
## setwd() generates a warning indicating setwd is effective only for this code chunk. Added warnings=FALSE to suppress this warning

currDir <- getwd()
setwd("C:/Study/IUMSDS/Spring2019/Applied DS/data")

df <- read.csv('gapminder.csv')

```
## DESCRIBING THE DATASET

```{r}
# line1 holds the dimension of the data frame.
line1 <- paste("The data set contains ",nrow(df), "observations, each observation with", ncol(df), "attributes(variables)")

#Function to return count of unique values 
getCountD <- function(x){
   length(unique(x))
}


#Loop to access all attributes of the data set and store data type, number of unique values in a string 'lineD'

lineD <- " "
for (col in names(df)){
  dtype <- sapply(df,class)[match(col, names(df))]
  lineD <- paste(lineD ,'\n',"- Attribute",col,"is of data type",dtype,"and has",sapply(df,getCountD)[match(col, names(df))],"unique values.")

#Added below code to show how dispersed an integer attribute is in this dataset
  if (dtype == "integer"){
      lineD <- paste(lineD, "\n","\t","- The range of",col,"is from", min(df[[col]], na.rm=TRUE),"to",max(df[[col]], na.rm=TRUE))
  }
}


```
<!--

```{r}
getDetail <- function(in_df){
  
    # line1 holds the dimension of the data frame.
    line1 <- paste("The data set contains ",nrow(df), "observations, each observation with", ncol(df), "attributes(variables)")
    
    #Function to return count of unique values 
    getCountD <- function(x){
       length(unique(x))
}

    #Loop to access all attributes of the data set and store data type, number of unique values in a string 'lineD'

    lineD <- " "
    for (col in names(in_df)){
      dtype <- sapply(in_df,class)[match(col, names(in_df))]
      lineD <- paste(lineD ,'\n',"- Attribute",col,"is of data type",dtype,"and has",sapply(in_df,getCountD)[match(col, names(in_df))],"unique values.")
    
    #Added below code to show how dispersed an integer attribute is in this dataset
      if (dtype == "integer"){
          lineD <- paste(lineD, "\n","\t","- The range of",col,"is from", min(in_df[[col]], na.rm=TRUE),"to",max(in_df[[col]], na.rm=TRUE))
      }
    }
    
}

getDetail(df)

## line1 and lineD are then printed using inline R code as below :
```
-->
- `r line1`

`r lineD`

## CHECKING NULL VALUES

```{r}
#Following for loop indicates that there are 2341 null values in 'income' column of the dataset

for (col in (names(df))){
  print(paste(col, "nulls:",sum(is.na(df[[col]]))))
}

```


#####################################  


## DATA WRANGLING

- convert population to integer
- select only years where population is > 0


```{r}
#Selecting only those years where population value is available.

df_pop <- filter(df, df$Year%%10 == 0)

#Converting population column from factor to an integer column
#Removing commas from population column

df_pop$poulation1 <- as.integer(gsub(",","",as.character(df_pop$population)))

```
```{r echo=FALSE}
# line1 holds the dimension of the data frame.
line1 <- paste("The data set contains ",nrow(df_pop), "observations, each observation with", ncol(df_pop), "attributes(variables)")

#Function to return count of unique values 
getCountD <- function(x){
   length(unique(x))
}


#Loop to access all attributes of the data set and store data type, number of unique values in a string 'lineD'

lineD <- " "
for (col in names(df_pop)){
  dtype <- sapply(df_pop, class)[match(col, names(df_pop))]
  lineD <- paste(lineD ,'\n',"- Attribute",col,"is of data type",dtype,"and has",sapply(df_pop, getCountD)[match(col, names(df_pop))],"unique values.")

#Added below code to show how dispersed an integer attribute is in this dataset
  if (dtype == "integer"){
      lineD <- paste(lineD, "\n","\t","- The range of",col,"is from", min(df_pop[[col]], na.rm=TRUE),"to",max(df_pop[[col]], na.rm=TRUE))
  }
}

```
For the new data : 
`r line1`
`r lineD`

```{r}
## Creating a data frame with details of 'India'
df_india <- filter(df, df$Country=='India')

## Calculating a column population1 by removing "," from column population
df_india$population1 <- as.integer(gsub(",","",as.character(df_india$population)))

## Definig a function which returns applicable population for given year.
## e.g. for year 1905 it will return population of year 1900
#x is year
getPop <- function(x){
  if (x%%10 == 0){
    as.integer(filter(df_india, df_india$Year==x)['population1'])
  }
  else {
    as.integer(filter(df_india, df_india$Year==(x - x%%10))['population1'])
  }
}

## Creating a dataframe with additional column 'calc_pop' which holds the applicable population for that year
df_india_new <- df_india %>%
  mutate(calc_pop = sapply(df_india$Year,getPop))

```

## EXPLORATORY DATA ANALYSIS

```{r}
## CHECKING MEDIAN LIFE EXPECTANCY FOR EACH REGION
print("MEDIAN LIFE EXPECTANCY FOR EACH REGION : ")
aggregate(life ~ region, df, median)

## CHECKING MEAN LIFE EXPECTANCY FOR EACH REGION
print("MEAN LIFE EXPECTANCY FOR EACH REGION : ")
aggregate(life ~ region, df, mean)

max(df$Year)

df_2015 <- filter(df, df$Year==2015)

incomeRegion <- df_2015 %>% 
  group_by(region) %>% 
  summarize(avgIncome = mean(income))


# plotting avg income for each region for year 2015

ggplot(incomeRegion, 
  aes(x = region, y = avgIncome, color = region)) +
  geom_point(size=4) +
  ggtitle("2015 Average Income by Region") +
  xlab("Region") + ylab("Avg. Income") +
  theme(axis.text.x=element_text(angle=10))

```


```{r}
RegionTrend <- df %>% 
  group_by(Year, region) %>% 
  summarize(avgIncome = mean(income, na.rm=TRUE), avgLife = mean(life,na.rm = TRUE))

ggplot(RegionTrend, 
  aes(x = Year, y = avgIncome, color = region)) +
  geom_smooth(se=FALSE) +
  ggtitle("Time trend of Average Income by Region") +
  xlab("Year") + ylab("Avg. Income") 

ggplot(RegionTrend, 
  aes(x = Year, y = avgLife, color = region)) +
  geom_smooth(se=FALSE) +
  ggtitle("Time trend of Average Life expectancy by Region") +
  xlab("Year") + ylab("Avg. Life expectancy")  

```

```{r}
ggplot(df_2015, aes(x = region, y = life)) +
  geom_boxplot(outlier.colour = "hotpink") +
  geom_jitter(position = position_jitter(width = 0.1, height = 0), alpha = 1/4) +
  ggtitle("Box plot of life expectancy by Region for year 2015") +
  ylab("Life expectancy") + xlab("Region")  +
  coord_flip() 
  
```


- TO SHOW THAT, OVER THE PERIOD DEPENDENCY OF LIFE EXPECTANCY ON INCOME HAS REDUCED

```{r}
#library(gridExtra)

## TO SHOW THAT, OVER THE PERIOD DEPENDENCY OF LIFE EXPECTANCY ON INCOME HAS REDUCED
df_1900 <- filter(df, df$Year==1900)

#par( mfrow = c(2,2) )

#p1 <- 
ggplot(data=df_1900) +
  geom_point(mapping = aes(x=income, y=life, color=region, alpha=0.4)) +
  ggtitle("High dependency of life expectancy on income for year 1900") +
  ylab("Life expectancy") + xlab("Income")  
  #theme(legend.position="bottom")

#p2 <- 
ggplot(data=df_2015) +
  geom_point(mapping = aes(x=income, y=life, color=region, alpha=0.4)) +
  ggtitle("Low dependency of life expectancy on income for year 2015") +
  ylab("Life expectancy") + xlab("Income")  
  #theme(legend.position="bottom")

#grid.arrange(p1,p2,ncol=2)

```

```{r}

corrplot(cor(df_india_new[c('Year','life','income','calc_pop')]),addCoef.col="grey")

df_india_new[c('Year','life','income','calc_pop')]

```